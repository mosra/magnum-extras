<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Magnum glTF Player</title>
  <link rel="stylesheet" href="WebApplication.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
</head>
<body>
  <h1>Magnum Player</h1>
  <div class="mn-container">
    <div class="mn-sizer"><div class="mn-expander"><div class="mn-listener">
      <canvas class="mn-canvas" id="canvas"></canvas>
      <div class="mn-status" id="status">Initialization...</div>
      <div class="mn-status-description" id="status-description"></div>
      <script src="EmscriptenApplication.js"></script>
      <script async="async" src="magnum-player.js"></script>
    </div></div></div>
  </div>
  <script>
    "use strict"; /* it summons the Cthulhu in a proper way, they say */

    /* Done here in addition to using
       EmscriptenApplication::setContainerCssClass() so we can do extra things
       like hiding scrollbars on magnum.graphics (none of that needed here,
       tho). The original function still needs to be called in order to
       properly propagate window size changes. */
    Module.setFullsize = function(fullsize) {};

    Module.keyboardListeningElement = Module.canvas;
    Module.canvas.addEventListener('dragover', function(event) {
        event.stopPropagation();
        event.preventDefault();
        event.dataTransfer.dropEffect = 'copy';
    });
    Module.canvas.addEventListener('drop', function(event) {
        event.stopPropagation();
        event.preventDefault();

        const items = event.dataTransfer.items;
        if(!items) {
            console.error("No files dropped.");
            return;
        }

        /* Unrecurse the bag of dropped files and directories and then pass all
           files through to the player. Memory is allocated on the JS side and
           freed on the C++ side to avoid needless copies. The
           webkitGetAsEntry() is Chrome-specific and Firefox with Edge were
           forced to implement it, despite the name. Safari and IE don't know
           that, so we need to be careful. */
        var files = [];
        var traverseFiles = function(fileOrDirectory, path/*, files*/) {
            if(fileOrDirectory.isFile) {
//                 console.log(files);
                files.push([fileOrDirectory, path]);
            } else if(fileOrDirectory.isDirectory) {
                let dirReader = fileOrDirectory.createReader();
                let getE = function() {
                dirReader.readEntries(function(entries) {
                    for(let i = 0; i != entries.length; ++i) {
                        traverseFiles(entries[i], path + fileOrDirectory.name + "/"/*, files*/);
                    }
                });
                }

                getE();
            }
        };
        for(let i = 0; i != items.length; ++i) {
            /* TODO: this might get renamed to getAsEntry() in 2027 or so */
            if(typeof items[i].webkitGetAsEntry === "function") {
                traverseFiles(items[i].webkitGetAsEntry(), ""/*, files*/);
                continue;
            }

            /* If webkitGetAsEntry() is not supported or the dumpster is on
               fire some other way, simply push the file directly (it will fail
               later if directories are involved). This is duplicated below
               for the case of webkitGetAsEntry() supported -- it uses a
               different variable for total count and adds file path to the
               filename. */
            (function(file) {
                const fileReader = new FileReader();
                fileReader.onload = function(event) {
                    /* TODO: but still, isn't here way too much copying? */
                    const fileData = new Uint8Array(event.target.result);
                    const pointer = Module._malloc(fileData.length);
                    const data = new Uint8Array(Module.HEAPU8.buffer, pointer, fileData.length);
                    data.set(fileData);
                    Module.ccall('loadFile', null, ['number', 'string', 'number', 'number'], [items.length, file.name, pointer, fileData.length]);
                };
                fileReader.onerror = function() {
                    console.error("Unable to read file " + file.name);
                };
                fileReader.readAsArrayBuffer(file);
            })(items[i]); /* this is how you do a capturing lambda?! ugh */
        }
        console.log(files.length);
        for(let i = 0; i != files.length; ++i) {
            console.log("ugh", i);
        (function(file, path) {
            file.file(function(file) {
                const fileReader = new FileReader();
                fileReader.onload = function(event) {
                    /* TODO: but still, isn't here way too much copying? */
                    const fileData = new Uint8Array(event.target.result);
                    const pointer = Module._malloc(fileData.length);
                    const data = new Uint8Array(Module.HEAPU8.buffer, pointer, fileData.length);
                    data.set(fileData);
                    Module.ccall('loadFile', null, ['number', 'string', 'number', 'number'], [files.length, path + file.name, pointer, fileData.length]);
                };
                fileReader.onerror = function() {
                    console.error("Unable to read file " + file.name);
                };
                fileReader.readAsArrayBuffer(file);
            });
        })(files[i][0], files[i][1]); /* insane?! is this needed? */
        }
    });
    Module.canvas.addEventListener('mousedown', function(event) {
        event.target.focus();
    });
    Module.canvas.addEventListener('contextmenu', function(event) {
        event.preventDefault();
    }, true);
  </script>
</body>
</html>
