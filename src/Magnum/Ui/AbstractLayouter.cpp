/*
    This file is part of Magnum.

    Copyright © 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019,
                2020, 2021, 2022, 2023, 2024, 2025
              Vladimír Vondruš <mosra@centrum.cz>

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

#include "AbstractLayouter.h"

#include <Corrade/Containers/BitArray.h>
#include <Corrade/Containers/BitArrayView.h>
#include <Corrade/Containers/GrowableArray.h>
#include <Corrade/Containers/EnumSet.hpp>
#include <Corrade/Containers/StridedArrayView.h>
#include <Magnum/Math/Vector2.h>

#include "Magnum/Ui/Handle.h"

namespace Magnum { namespace Ui {

Debug& operator<<(Debug& debug, const LayouterState value) {
    debug << "Ui::LayouterState" << Debug::nospace;

    switch(value) {
        /* LCOV_EXCL_START */
        #define _c(value) case LayouterState::value: return debug << "::" #value;
        _c(NeedsUpdate)
        _c(NeedsAssignmentUpdate)
        #undef _c
        /* LCOV_EXCL_STOP */
    }

    return debug << "(" << Debug::nospace << Debug::hex << UnsignedByte(value) << Debug::nospace << ")";
}

Debug& operator<<(Debug& debug, const LayouterStates value) {
    return Containers::enumSetDebugOutput(debug, value, "Ui::LayouterStates{}", {
        LayouterState::NeedsAssignmentUpdate,
        /* Implied by NeedsAssignmentUpdate, has to be after */
        LayouterState::NeedsUpdate
    });
}

namespace {

union Layout {
    explicit Layout() noexcept: used{} {}

    struct Used {
        /* Together with index of this item in `layouts` used for creating a
           LayouterDataHandle. Increased every time a handle reaches remove().
           Has to be initially non-zero to differentiate the first ever handle
           (with index 0) from LayouterDataHandle::Null. Once becomes
           `1 << LayouterDataHandleGenerationBits` the handle gets disabled. */
        UnsignedShort generation = 1;

        /* Two bytes free */

        /* Node the layout is assigned to. Is null only when the layout is
           freed. Has to be re-filled every time a handle is recycled, so it
           doesn't make sense to initialize it to anything. isHandleValid()
           checks this field to correctly mark invalid handles if the
           generation matches by accident. */
        NodeHandle node;

        /* Four bytes free */
    } used;

    /* Used only if the Layout is among free ones */
    struct Free {
        /* The generation value has to be preserved in order to increment it
           next time it gets used */
        UnsignedShort generation;

        /* Two bytes free */

        /* If this is null, the layout is freed */
        /** @todo any idea how to better pack this? this is a bit awful */
        NodeHandle node;

        /* See State::firstFree for more information */
        UnsignedInt next;
    } free;
};

#ifndef CORRADE_NO_STD_IS_TRIVIALLY_TRAITS
static_assert(std::is_trivially_copyable<Layout>::value, "Layout not trivially copyable");
#endif
static_assert(
    offsetof(Layout::Used, generation) == offsetof(Layout::Free, generation) &&
    offsetof(Layout::Used, node) == offsetof(Layout::Free, node),
    "Layout::Used and Free layout not compatible");

}

struct AbstractLayouter::State {
    LayouterHandle handle;
    LayouterStates state;

    #ifndef CORRADE_NO_ASSERT
    bool setSizeCalled = false;
    #endif
    /* 0/4 bytes free, 1/5 on a no-assert build */

    Containers::Array<Layout> layouts;
    /* Indices in the `layouts` array. The Layout then has a nextFree member
       containing the next free index. New layouts get taken from the front,
       removed are put at the end. A value of ~UnsignedInt{} means there's no
       (first/next/last) free layout. */
    UnsignedInt firstFree = ~UnsignedInt{};
    UnsignedInt lastFree = ~UnsignedInt{};
};

AbstractLayouter::AbstractLayouter(const LayouterHandle handle): _state{InPlaceInit} {
    CORRADE_ASSERT(handle != LayouterHandle::Null,
        "Ui::AbstractLayouter: handle is null", );
    _state->handle = handle;
}

AbstractLayouter::AbstractLayouter(AbstractLayouter&&) noexcept = default;

AbstractLayouter::~AbstractLayouter() = default;

AbstractLayouter& AbstractLayouter::operator=(AbstractLayouter&&) noexcept = default;

LayouterHandle AbstractLayouter::handle() const {
    return _state->handle;
}

LayouterStates AbstractLayouter::state() const {
    return _state->state;
}

void AbstractLayouter::setNeedsUpdate() {
    _state->state |= LayouterState::NeedsUpdate;
}

std::size_t AbstractLayouter::capacity() const {
    return _state->layouts.size();
}

std::size_t AbstractLayouter::usedCount() const {
    /* In general we can assume that the amount of free data is always either
       zero or significantly less than the capacity, and thus iterating the
       (presumably small) free list should be faster, even though it involves
       jumping around in memory. */
    const State& state = *_state;
    std::size_t free = 0;
    UnsignedInt index = state.firstFree;
    while(index != ~UnsignedInt{}) {
        index = state.layouts[index].free.next;
        ++free;
    }
    return state.layouts.size() - free;
}

bool AbstractLayouter::isHandleValid(const LayouterDataHandle handle) const {
    if(handle == LayouterDataHandle::Null)
        return false;
    const State& state = *_state;
    const UnsignedInt index = layouterDataHandleId(handle);
    if(index >= state.layouts.size())
        return false;
    const UnsignedInt generation = layouterDataHandleGeneration(handle);
    const Layout& layout = state.layouts[index];
    /* Zero generation handles (i.e., where it wrapped around from all bits
       set) are expected to be expired and thus with node being null. In other
       words, it shouldn't be needed to verify also that generation is
       non-zero. */
    CORRADE_INTERNAL_DEBUG_ASSERT(generation || layout.used.node == NodeHandle::Null);
    return layout.used.node != NodeHandle::Null && generation == layout.used.generation;
}

bool AbstractLayouter::isHandleValid(const LayoutHandle handle) const {
    return layoutHandleLayouter(handle) == _state->handle && isHandleValid(layoutHandleData(handle));
}

LayoutHandle AbstractLayouter::add(const NodeHandle node) {
    CORRADE_ASSERT(node != NodeHandle::Null,
        "Ui::AbstractLayouter::add(): invalid handle" << node, {});

    State& state = *_state;

    /* Find the first free layout if there is, update the free index to point
       to the next one (or none) */
    Layout* layout;
    if(state.firstFree!= ~UnsignedInt{}) {
        layout = &state.layouts[state.firstFree];

        if(state.firstFree == state.lastFree) {
            CORRADE_INTERNAL_ASSERT(layout->free.next == ~UnsignedInt{});
            state.firstFree = state.lastFree = ~UnsignedInt{};
        } else {
            state.firstFree = layout->free.next;
        }

    /* If there isn't, allocate a new one */
    } else {
        CORRADE_ASSERT(state.layouts.size() < 1 << Implementation::LayouterDataHandleIdBits,
            "Ui::AbstractLayouter::add(): can only have at most" << (1 << Implementation::LayouterDataHandleIdBits) << "layouts", {});
        layout = &arrayAppend(state.layouts, InPlaceInit);
    }

    /* Fill the data. In both above cases the generation is already set
       appropriately, either initialized to 1, or incremented when it got
       remove()d (to mark existing handles as invalid) */
    layout->used.node = node;

    /* Mark the layouter as needing an update() call */
    state.state |= LayouterState::NeedsAssignmentUpdate;

    return layoutHandle(state.handle, (layout - state.layouts), layout->used.generation);
}

void AbstractLayouter::remove(const LayoutHandle handle) {
    CORRADE_ASSERT(isHandleValid(handle),
        "Ui::AbstractLayouter::remove(): invalid handle" << handle, );

    _state->state |= LayouterState::NeedsAssignmentUpdate;

    /* Doesn't delegate to remove(LayouterNodeHandle) to avoid a double check;
       doesn't check just the layouter portion of the handle and delegate to
       avoid a confusing assertion message if the data portion would be
       invalid */
    removeInternal(layoutHandleId(handle));
}

void AbstractLayouter::remove(const LayouterDataHandle handle) {
    CORRADE_ASSERT(isHandleValid(handle),
        "Ui::AbstractLayouter::remove(): invalid handle" << handle, );

    _state->state |= LayouterState::NeedsAssignmentUpdate;

    removeInternal(layouterDataHandleId(handle));
}

void AbstractLayouter::removeInternal(const UnsignedInt id) {
    State& state = *_state;
    Layout& layout = state.layouts[id];

    /* Increase the layout generation so existing handles pointing to this
       layout are invalidated. Wrap around to 0 if it goes over the generation
       bits. */
    ++layout.used.generation &= (1 << Implementation::LayouterDataHandleGenerationBits) - 1;

    /* Set the node attachment to null to avoid falsely recognizing this item
       as used when directly iterating the list or in isHandleValid() if the
       generation matches by accident */
    layout.used.node = NodeHandle::Null;

    /* Put the layout at the end of the free list (while they're allocated from
       the front) to not exhaust the generation counter too fast. If the free
       list is empty however, update also the index of the first free layer.

       Don't do this if the generation wrapped around. That makes it disabled,
       i.e. impossible to be recycled later, to avoid aliasing old handles. */
    if(layout.used.generation != 0) {
        layout.free.next = ~UnsignedInt{};
        if(state.lastFree == ~UnsignedInt{}) {
            CORRADE_INTERNAL_ASSERT(
                state.firstFree == ~UnsignedInt{} &&
                state.lastFree == ~UnsignedInt{});
            state.firstFree = id;
        } else {
            state.layouts[state.lastFree].free.next = id;
        }
        state.lastFree = id;
    }

    /* Updating LayouterState (or not) is caller's responsibility. For example,
       clean() below doesn't set any state after calling removeInternal(). */
}

NodeHandle AbstractLayouter::node(LayoutHandle layout) const {
    CORRADE_ASSERT(isHandleValid(layout),
        "Ui::AbstractLayouter::node(): invalid handle" << layout, {});
    return _state->layouts[layoutHandleId(layout)].used.node;
}

NodeHandle AbstractLayouter::node(LayouterDataHandle layout) const {
    CORRADE_ASSERT(isHandleValid(layout),
        "Ui::AbstractLayouter::node(): invalid handle" << layout, {});
    return _state->layouts[layouterDataHandleId(layout)].used.node;
}

Containers::StridedArrayView1D<const NodeHandle> AbstractLayouter::nodes() const {
    return stridedArrayView(_state->layouts).slice(&Layout::used).slice(&Layout::Used::node);
}

Containers::StridedArrayView1D<const UnsignedShort> AbstractLayouter::generations() const {
    return stridedArrayView(_state->layouts).slice(&Layout::used).slice(&Layout::Used::generation);
}

void AbstractLayouter::setSize(const Vector2& size) {
    CORRADE_ASSERT(size.product(),
        "Ui::AbstractLayouter::setSize(): expected a non-zero size, got" << size, );
    #ifndef CORRADE_NO_ASSERT
    _state->setSizeCalled = true;
    #endif
    doSetSize(size);
}

void AbstractLayouter::doSetSize(const Vector2&) {}

void AbstractLayouter::cleanNodes(const Containers::StridedArrayView1D<const UnsignedShort>& nodeHandleGenerations) {
    State& state = *_state;
    /** @todo have some bump allocator for this */
    Containers::BitArray layoutIdsToRemove{ValueInit, state.layouts.size()};

    for(std::size_t i = 0; i != state.layouts.size(); ++i) {
        const Layout& layout = state.layouts[i];

        /* Skip layouts that are free */
        if(layout.used.node == NodeHandle::Null)
            continue;

        /* For used layout compare the generation of the node they're attached
           to. If it differs, remove the layout and mark the corresponding
           index so the implementation can do its own cleanup in doClean(). */
        /** @todo check that the ID is in bounds and if it's not, remove as
            well? to avoid OOB access if the layout is accidentally attached to
            a NodeHandle from a different UI instance that has more nodes */
        if(nodeHandleGeneration(layout.used.node) != nodeHandleGenerations[nodeHandleId(layout.used.node)]) {
            removeInternal(i);
            layoutIdsToRemove.set(i);
        }
    }

    doClean(layoutIdsToRemove);
}

void AbstractLayouter::doClean(Containers::BitArrayView) {}

void AbstractLayouter::update(const Containers::BitArrayView layoutIdsToUpdate, const Containers::StridedArrayView1D<const UnsignedInt>& topLevelLayoutIds, const Containers::StridedArrayView1D<const NodeHandle>& nodeParents, const Containers::StridedArrayView1D<Vector2>& nodeOffsets, const Containers::StridedArrayView1D<Vector2>& nodeSizes) {
    CORRADE_ASSERT(layoutIdsToUpdate.size() == capacity(),
        "Ui::AbstractLayouter::update(): expected layoutIdsToUpdate to have" << capacity() << "bits but got" << layoutIdsToUpdate.size(), );
    CORRADE_ASSERT(nodeOffsets.size() == nodeParents.size() && nodeSizes.size() == nodeParents.size(),
        "Ui::AbstractLayouter::update(): expected node parent, offset and size views to have the same size but got" << nodeParents.size() << Debug::nospace << "," << nodeOffsets.size() << "and" << nodeSizes.size(), );
    State& state = *_state;
    CORRADE_ASSERT(state.setSizeCalled,
        "Ui::AbstractLayouter::update(): user interface size wasn't set", );
    doUpdate(layoutIdsToUpdate, topLevelLayoutIds, nodeParents, nodeOffsets, nodeSizes);
    state.state &= ~LayouterState::NeedsAssignmentUpdate;
}

}}
